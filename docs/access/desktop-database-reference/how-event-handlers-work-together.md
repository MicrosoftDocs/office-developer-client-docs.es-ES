---
title: Cómo funcionan los controladores de eventos combinados
TOCTitle: How event handlers work together
ms:assetid: 02122824-881e-0bb8-cba1-c963024790ae
ms:mtpsurl: https://msdn.microsoft.com/library/JJ248788(v=office.15)
ms:contentKeyID: 48542951
ms.date: 09/18/2015
mtps_version: v=office.15
localization_priority: Normal
ms.openlocfilehash: e772e93f27d6bb5f30d865e3435d4bde6bdc5e73
ms.sourcegitcommit: 8fe462c32b91c87911942c188f3445e85a54137c
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 04/23/2019
ms.locfileid: "32291925"
---
# <a name="how-event-handlers-work-together"></a><span data-ttu-id="93174-102">Cómo funcionan los controladores de eventos combinados</span><span class="sxs-lookup"><span data-stu-id="93174-102">How event handlers work together</span></span>

<span data-ttu-id="93174-103">**Se aplica a:** Access 2013, Office 2013</span><span class="sxs-lookup"><span data-stu-id="93174-103">**Applies to**: Access 2013, Office 2013</span></span>

<span data-ttu-id="93174-p101">A menos que se programe en Visual Basic, todos los controladores de eventos **Connection** y **Recordset** deben estar implementados, independientemente de que se procesen realmente todos los eventos. La cantidad de trabajo que implica la implementación depende del lenguaje de programación. Para obtener más información, vea [ Creación de instancias de eventos de ADO por lenguaje](https://docs.microsoft.com/office/client-developer/access/desktop-database-reference/ado-event-instantiation-by-language-ado).</span><span class="sxs-lookup"><span data-stu-id="93174-p101">Unless you are programming in Visual Basic, all event handlers for **Connection** and **Recordset** events must be implemented, regardless of whether you actually process all of the events. The amount of implementation work you have to do depends on your programming language. For more information, see [ADO Event Instantiation by Language](https://docs.microsoft.com/office/client-developer/access/desktop-database-reference/ado-event-instantiation-by-language-ado).</span></span>

## <a name="paired-event-handlers"></a><span data-ttu-id="93174-107">Controladores de eventos emparejados</span><span class="sxs-lookup"><span data-stu-id="93174-107">Paired event handlers</span></span>

<span data-ttu-id="93174-p102">Cada controlador de eventos Will tiene asociado un controlador de eventos Complete. Por ejemplo, cuando una aplicación cambia el valor de un campo, se llama al controlador de eventos **WillChangeField**. Si el cambio es aceptable, la aplicación no modifica el parámetro **adStatus** y se lleva a cabo la operación. Cuando finaliza la operación, un evento **FieldChangeComplete** notifica a la aplicación la finalización de la operación. Si ésta ha finalizado correctamente, **adStatus** contiene **adStatusOK**; en caso contrario, **adStatus** contiene **adStatusErrorsOccurred** y es preciso comprobar el objeto **Error** para determinar la causa del error.</span><span class="sxs-lookup"><span data-stu-id="93174-p102">Each Will event handler has an associated Complete event handler. For example, when your application changes the value of a field, the **WillChangeField** event handler is called. If the change is acceptable, your application leaves the **adStatus** parameter unchanged and the operation is performed. When the operation completes, a **FieldChangeComplete** event notifies your application that the operation has finished. If it completed successfully, **adStatus** contains **adStatusOK**; otherwise, **adStatus** contains **adStatusErrorsOccurred** and you must check the **Error** object to determine the cause of the error.</span></span>

<span data-ttu-id="93174-p103">Cuando se llama a **WillChangeField**, es posible que se determine que no se debió realizar el cambio. En ese caso, establezca el valor de **adStatus** en **adStatusCancel**. Se cancela la operación y el evento **FieldChangeComplete** recibe para **adStatus** el valor **adStatusErrorsOccurred**. El objeto **Error** contiene **adErrOperationCancelled** para que el controlador **FieldChangeComplete** sepa que se canceló la operación. Sin embargo, es preciso comprobar el valor del parámetro **adStatus** antes de cambiarlo, porque establecer el valor de **adStatus** en **adStatusCancel** no tiene ningún efecto si el parámetro se estableció en **adStatusCantDeny** al iniciarse el procedimiento.</span><span class="sxs-lookup"><span data-stu-id="93174-p103">When **WillChangeField** is called, you might determine that the change should not be made. In that case, set **adStatus** to **adStatusCancel**. The operation is canceled and the **FieldChangeComplete** event receives an **adStatus** value of **adStatusErrorsOccurred**. The **Error** object contains **adErrOperationCancelled** so that your **FieldChangeComplete** handler knows that the operation was canceled. However, you need to check the value of the **adStatus** parameter before changing it, because setting **adStatus** to **adStatusCancel** has no effect if the parameter was set to **adStatusCantDeny** on entry to the procedure.</span></span>

<span data-ttu-id="93174-p104">A veces, una operación puede producir varios eventos. Por ejemplo, el objeto **Recordset** tiene eventos emparejados para los cambios de **Field** y **Record**. Cuando la aplicación cambia el valor de un **Field**, se llama al controlador de eventos **WillChangeField**. Si determina que la operación puede continuar, también se llamará al controlador de eventos **WillChangeRecord**. Si este controlador permite asimismo que continúe el evento, se realiza el cambio y se llama a los controladores de eventos **FieldChangeComplete** y **RecordChangeComplete**. El orden en que se llama a los controladores de eventos Will para una determinada operación no está definido, por lo que debe evitarse escribir código que requiera que se llame a los controladores de eventos en una secuencia determinada.</span><span class="sxs-lookup"><span data-stu-id="93174-p104">Sometimes an operation can raise more than one event. For example, the **Recordset** object has paired events for **Field** changes and **Record** changes. When your application changes the value of a **Field**, the **WillChangeField** event handler is called. If it determines that the operation can continue, the **WillChangeRecord** event handler is also raised. If this handler also allows the event to continue, the change is made and the **FieldChangeComplete** and **RecordChangeComplete** event handlers are called. The order in which the Will event handlers for a particular operation are called is not defined, so you should avoid writing code that depends on calling handlers in a particular sequence.</span></span>

<span data-ttu-id="93174-p105">En los casos en los que se provocan varios eventos Will, es posible que uno de los eventos cancele la operación que está pendiente. Por ejemplo, cuando la aplicación cambia el valor de un **Field**, normalmente se llama tanto al controlador de eventos **WillChangeField** como al controlador de eventos **WillChangeRecord**. Sin embargo, si se cancela la operación en el primer controlador de eventos, se llama inmediatamente a su controlador Complete asociado con **adStatusOperationCancelled**. No se llama nunca al segundo controlador. Sin embargo, si el primer controlador de eventos permite que el evento continúe, se llamará al otro controlador de eventos. Si cancela la operación, se llamará a ambos eventos Complete como en los ejemplos anteriores.</span><span class="sxs-lookup"><span data-stu-id="93174-p105">In instances when multiple Will events are raised, one of the events might cancel the pending operation. For example, when your application changes the value of a **Field**, both **WillChangeField** and **WillChangeRecord** event handlers would normally be called. However, if the operation is canceled in the first event handler, its associated Complete handler is immediately called with **adStatusOperationCancelled**. The second handler is never called. If, however, the first event handler allows the event to proceed, the other event handler will be called. If it then cancels the operation, both Complete events will be called as in the earlier examples.</span></span>

## <a name="unpaired-event-handlers"></a><span data-ttu-id="93174-130">Controladores de eventos no asociados</span><span class="sxs-lookup"><span data-stu-id="93174-130">Unpaired event handlers</span></span>

<span data-ttu-id="93174-p106">Siempre y cuando el estado pasado al evento no sea **adStatusCantDeny**, se pueden desencadenar las notificaciones de eventos para cualquier evento devolviendo **adStatusUnwantedEvent** en el parámetro *Status*. Por ejemplo, cuando se llama la primera vez al controlador de eventos Complete, puede devolver **adStatusUnwantedEvent**. Posteriormente, recibirá sólo los eventos Will. Sin embargo, algunos eventos pueden desencadenarse por varias razones. En ese caso, el evento tendrá un parámetro *Reason*. Si devuelve **adStatusUnwantedEvent**, dejará de recibir notificaciones de ese evento sólo si se produce por ese motivo concreto. Es decir, recibirá notificaciones por cada razón por la que se puede desencadenar el evento.</span><span class="sxs-lookup"><span data-stu-id="93174-p106">As long as the status passed to the event is not **adStatusCantDeny**, you can turn off event notifications for any event by returning **adStatusUnwantedEvent** in the *Status* parameter. For example, when your Complete event handler is called the first time, you can return **adStatusUnwantedEvent**. You will subsequently receive only Will events. However, some events can be triggered for more than one reason. In that case, the event will have a *Reason* parameter. When you return **adStatusUnwantedEvent**, you will stop receiving notifications for that event only when they occur for that particular reason. In other words, you will potentially receive notification for each possible reason that the event could be triggered.</span></span>

<span data-ttu-id="93174-p107">Los controladores de eventos Will pueden ser útiles cuando desea examinar los parámetros que se van a utilizar en una operación. Puede modificar esos parámetros de operación o cancelar la operación.</span><span class="sxs-lookup"><span data-stu-id="93174-p107">Single Will event handlers can be useful when you want to examine the parameters that will be used in an operation. You can modify those operation parameters or cancel the operation.</span></span>

<span data-ttu-id="93174-p108">Como alternativa, deje habilitada la notificación de eventos Complete. Cuando se llame al primer controlador de eventos Will, devuelva **adStatusUnwantedEvent**. Posteriormente, sólo recibirá los eventos Complete.</span><span class="sxs-lookup"><span data-stu-id="93174-p108">Alternatively, leave Complete event notification enabled. When your first Will event handler is called, return **adStatusUnwantedEvent**. You will subsequently receive only Complete events.</span></span>

<span data-ttu-id="93174-p109">Los controladores de eventos Complete pueden ser útiles para administrar las operaciones asincrónicas. Cada operación asincrónica tiene un evento Complete correspondiente.</span><span class="sxs-lookup"><span data-stu-id="93174-p109">Single Complete event handlers can be useful for managing asynchronous operations. Each asynchronous operation has an appropriate Complete event.</span></span>

<span data-ttu-id="93174-145">Por ejemplo, puede que tarde mucho tiempo en rellenar un objeto [Recordset](recordset-object-ado.md) de gran tamaño.</span><span class="sxs-lookup"><span data-stu-id="93174-145">For example, it can take a long time to populate a large [Recordset](recordset-object-ado.md) object.</span></span> <span data-ttu-id="93174-146">Si la aplicación está correctamente escrita, puede iniciar una operación y continuar con otro procesamiento.</span><span class="sxs-lookup"><span data-stu-id="93174-146">If your application is appropriately written, you can start a operation and continue with other processing.</span></span> <span data-ttu-id="93174-147">You will eventually be notified when the **Recordset** is populated by an **ExecuteComplete** event.</span><span class="sxs-lookup"><span data-stu-id="93174-147">You will eventually be notified when the **Recordset** is populated by an **ExecuteComplete** event.</span></span>

## <a name="single-event-handlers-and-multiple-objects"></a><span data-ttu-id="93174-148">Controladores de eventos únicos y varios objetos</span><span class="sxs-lookup"><span data-stu-id="93174-148">Single event handlers and multiple objects</span></span>

<span data-ttu-id="93174-p111">La flexibilidad de un lenguaje de programación como Microsoft Visual C++ permite que un controlador de eventos procese los eventos de varios objetos. Por ejemplo, un controlador de eventos **Disconnect** puede procesar los eventos de varios objetos **Connection**. Si una de las conexiones finaliza, se llamará al controlador de eventos **Disconnect**. Se podrá indicar cuál es la conexión que ha causado el evento porque el parámetro de objeto del controlador de eventos estará establecido en el correspondiente objeto **Connection**.</span><span class="sxs-lookup"><span data-stu-id="93174-p111">The flexibility of a programming language like Microsoft Visual C++ enables you to have one event handler process events from multiple objects. For example, you could have one **Disconnect** event handler process events from several **Connection** objects. If one of the connections ended, the **Disconnect** event handler would be called. You could tell which connection caused the event because the event-handler object parameter would be set to the corresponding **Connection** object.</span></span>

> [!NOTE]
> <span data-ttu-id="93174-153">[!NOTA] Esta técnica no se puede utilizar en Visual Basic porque este lenguaje sólo puede correlacionar un objeto con un controlador de eventos.</span><span class="sxs-lookup"><span data-stu-id="93174-153">This technique cannot be used in Visual Basic because that language can correlate only one object to an event handler.</span></span>


