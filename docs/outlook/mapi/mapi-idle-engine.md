---
title: Motor de inactividad de MAPI
manager: soliver
ms.date: 03/09/2015
ms.audience: Developer
localization_priority: Normal
api_type:
- COM
ms.assetid: 755d096a-2a61-44d2-a765-5d464a857756
description: 'Última modificación: 09 de marzo de 2015'
ms.openlocfilehash: 9fdc254053c2d35c83866bd8a076279fd383db02
ms.sourcegitcommit: 0cf39e5382b8c6f236c8a63c6036849ed3527ded
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 08/23/2018
ms.locfileid: "22583039"
---
# <a name="mapi-idle-engine"></a><span data-ttu-id="d1b75-103">Motor de inactividad de MAPI</span><span class="sxs-lookup"><span data-stu-id="d1b75-103">MAPI Idle Engine</span></span>

  
  
<span data-ttu-id="d1b75-104">**Hace referencia a**: Outlook 2013 | Outlook 2016</span><span class="sxs-lookup"><span data-stu-id="d1b75-104">**Applies to**: Outlook 2013 | Outlook 2016</span></span> 
  
<span data-ttu-id="d1b75-105">MAPI proporciona varias funciones que se conocen como el motor de inactividad.</span><span class="sxs-lookup"><span data-stu-id="d1b75-105">MAPI provides several functions that are collectively known as the idle engine.</span></span> <span data-ttu-id="d1b75-106">Estas funciones permiten a los clientes, los proveedores de la libreta de direcciones y los proveedores de almacén de mensajes realizar diversas tareas durante tiempos lentos en la sesión o en respuesta a un tiempo lento.</span><span class="sxs-lookup"><span data-stu-id="d1b75-106">These functions allow clients, address book providers, and message store providers to perform various tasks during slow times in the session or in response to a slow time.</span></span> <span data-ttu-id="d1b75-107">Por ejemplo, clientes y proveedores de servicios pueden aplazar operaciones lentas o cerrar los archivos que han permanecido sin usar durante un período extenso.</span><span class="sxs-lookup"><span data-stu-id="d1b75-107">For example, clients and service providers can defer slow operations or close files that have remained unused for a lengthy period.</span></span> <span data-ttu-id="d1b75-108">Normalmente, los proveedores de transporte no usar el motor de inactivo debido a que el método **IXPLogon::Idle** toma su lugar.</span><span class="sxs-lookup"><span data-stu-id="d1b75-108">Transport providers typically do not use the idle engine because the **IXPLogon::Idle** method takes its place.</span></span> <span data-ttu-id="d1b75-109">Para obtener más información, vea [IXPLogon::Idle](ixplogon-idle.md).</span><span class="sxs-lookup"><span data-stu-id="d1b75-109">For more information, see [IXPLogon::Idle](ixplogon-idle.md).</span></span>
  
<span data-ttu-id="d1b75-110">Para usar el motor de inactividad, clientes y proveedores de servicios de creación una función de devolución de llamada que contiene las tareas que deben producirse cuando el subsistema MAPI está inactivo.</span><span class="sxs-lookup"><span data-stu-id="d1b75-110">To use the idle engine, clients and service providers create a callback function that contains the tasks that should occur when the MAPI subsystem is idle.</span></span> <span data-ttu-id="d1b75-111">Cuando MAPI detecta el tiempo de inactividad, invoca esta función de devolución de llamada.</span><span class="sxs-lookup"><span data-stu-id="d1b75-111">When MAPI detects idle time, it invokes this callback function.</span></span> <span data-ttu-id="d1b75-112">La función de devolución de llamada sigue el prototipo **FNIDLE** , que se definen como sigue:</span><span class="sxs-lookup"><span data-stu-id="d1b75-112">The callback function follows the **FNIDLE** prototype, defined as follows:</span></span> 
  
 `BOOL (STDAPICALLTYPE FNIDLE) (LPVOID lpvContext)`
  
<span data-ttu-id="d1b75-113">Para obtener más información, vea [FNIDLE](fnidle.md).</span><span class="sxs-lookup"><span data-stu-id="d1b75-113">For more information, see [FNIDLE](fnidle.md).</span></span>
  
<span data-ttu-id="d1b75-114">Las funciones que componen el motor de inactividad son:</span><span class="sxs-lookup"><span data-stu-id="d1b75-114">The functions that make up the idle engine are:</span></span>
  
[<span data-ttu-id="d1b75-115">ChangeIdleRoutine</span><span class="sxs-lookup"><span data-stu-id="d1b75-115">ChangeIdleRoutine</span></span>](changeidleroutine.md)
  
[<span data-ttu-id="d1b75-116">DeregisterIdleRoutine</span><span class="sxs-lookup"><span data-stu-id="d1b75-116">DeregisterIdleRoutine</span></span>](deregisteridleroutine.md)
  
[<span data-ttu-id="d1b75-117">EnableIdleRoutine</span><span class="sxs-lookup"><span data-stu-id="d1b75-117">EnableIdleRoutine</span></span>](enableidleroutine.md)
  
[<span data-ttu-id="d1b75-118">FtgRegisterIdleRoutine</span><span class="sxs-lookup"><span data-stu-id="d1b75-118">FtgRegisterIdleRoutine</span></span>](ftgregisteridleroutine.md)
  
[<span data-ttu-id="d1b75-119">MAPIDeInitIdle</span><span class="sxs-lookup"><span data-stu-id="d1b75-119">MAPIDeInitIdle</span></span>](mapideinitidle.md)
  
[<span data-ttu-id="d1b75-120">MAPIInitIdle</span><span class="sxs-lookup"><span data-stu-id="d1b75-120">MAPIInitIdle</span></span>](mapiinitidle.md)
  
<span data-ttu-id="d1b75-121">Para registrar una función de devolución de llamada, los clientes y proveedores de servicios de llamar a la función **FtgRegisterIdleRoutine** .</span><span class="sxs-lookup"><span data-stu-id="d1b75-121">To register a callback function, clients and service providers call the **FtgRegisterIdleRoutine** function.</span></span> <span data-ttu-id="d1b75-122">Los parámetros de entrada incluyen una prioridad opcional, un bloque de memoria que se pasa a la función de devolución de llamada como entrada, una cantidad de tiempo que se usará de forma apropiada, y un conjunto de opción marcas.</span><span class="sxs-lookup"><span data-stu-id="d1b75-122">The input parameters include an optional priority, a block of memory that is passed to your callback function as input, an amount of time to be used in any way appropriate, and a set of option flags.</span></span> 
  
<span data-ttu-id="d1b75-123">Los clientes y proveedores de servicios pueden especificar una prioridad en el parámetro _priIdle_ que controla cómo se ejecuta la función inactivo o especificar cero si la prioridad no es un problema.</span><span class="sxs-lookup"><span data-stu-id="d1b75-123">Clients and service providers can specify a priority in the  _priIdle_ parameter that controls how the idle function runs or specify zero if priority is not an issue.</span></span> <span data-ttu-id="d1b75-124">Debido a que los números negativos representan prioridades mayores que los números positivos o cero, se deben asignar las operaciones de búsqueda y la compresión de los números negativos.</span><span class="sxs-lookup"><span data-stu-id="d1b75-124">Because negative numbers represent higher priorities than positive numbers or zero, compression and search operations should be assigned negative numbers.</span></span> <span data-ttu-id="d1b75-125">Tareas que se producen una vez que se debe asignar a números positivos.</span><span class="sxs-lookup"><span data-stu-id="d1b75-125">Tasks that occur once should be assigned positive numbers.</span></span> 
  
<span data-ttu-id="d1b75-126">Para anular el registro de una función de devolución de llamada activa, clientes y proveedores de servicios de llamar a la función **DeregisterIdleRoutine** .</span><span class="sxs-lookup"><span data-stu-id="d1b75-126">To deregister an active callback function, clients and service providers call the **DeregisterIdleRoutine** function.</span></span> <span data-ttu-id="d1b75-127">Debido a que **DeregisterIdleRoutine** funciona de manera asincrónica, es posible para la función de devolución de llamada que va a invocar en cualquier momento durante la llamada Cancelar registro y, posiblemente, incluso después de que se devuelva **DeregisterIdleRoutine** .</span><span class="sxs-lookup"><span data-stu-id="d1b75-127">Because **DeregisterIdleRoutine** operates asynchronously, it is possible for the callback function to be invoked at any time during the deregister call and possibly even after **DeregisterIdleRoutine** has returned.</span></span> 
  
<span data-ttu-id="d1b75-128">Para modificar algunas o todas las características de una función de devolución de llamada, los clientes y proveedores de servicios de llamar a la función **ChangeIdleRoutine** .</span><span class="sxs-lookup"><span data-stu-id="d1b75-128">To modify some or all of the characteristics of a callback function, clients and service providers call the **ChangeIdleRoutine** function.</span></span> <span data-ttu-id="d1b75-129">**ChangeIdleRoutine** hace que cambia en función de cómo se establece el parámetro de indicadores _ircIdle_ ; **ChangeIdleRoutine** puede cambiar la propia función, su prioridad, configuración de hora y parámetro de entrada.</span><span class="sxs-lookup"><span data-stu-id="d1b75-129">**ChangeIdleRoutine** makes changes according to how the flags parameter  _ircIdle_ is set; **ChangeIdleRoutine** can change the function itself, its priority, time setting, and input parameter.</span></span> 
  
<span data-ttu-id="d1b75-130">MAPI define inactivo el mismo que el sistema operativo, cuando el sistema operativo tiene una definición.</span><span class="sxs-lookup"><span data-stu-id="d1b75-130">MAPI defines idle the same as the operating system, when the operating system has a definition.</span></span> <span data-ttu-id="d1b75-131">En Win32, MAPI crea un subproceso con prioridad de clase inactiva para programar tareas inactivas.</span><span class="sxs-lookup"><span data-stu-id="d1b75-131">On Win32, MAPI creates a thread with idle-class priority to schedule idle tasks.</span></span> <span data-ttu-id="d1b75-132">Este subproceso realiza un seguimiento de la hora y envía un mensaje al subproceso de la que va a ejecutar la tarea inactivo cuando llegue la hora para su ejecución.</span><span class="sxs-lookup"><span data-stu-id="d1b75-132">This thread keeps track of the time and posts a message to the thread that is to execute the idle task when the time for its execution arrives.</span></span> <span data-ttu-id="d1b75-133">Win32 programa los subprocesos, no se procesa.</span><span class="sxs-lookup"><span data-stu-id="d1b75-133">Win32 schedules threads, not processes.</span></span> <span data-ttu-id="d1b75-134">Si se están produciendo las tareas que tienen una prioridad superior a la prioridad de inactividad en la estación de trabajo, la tarea inactiva debe no obtener programada para su ejecución hasta que han completado las tareas.</span><span class="sxs-lookup"><span data-stu-id="d1b75-134">If tasks that have a priority higher than the idle priority are occurring on the workstation, the idle task should not get scheduled for execution until the tasks have completed.</span></span> 
  
<span data-ttu-id="d1b75-135">Todas las tareas inactivas se ejecutan en el subproceso que llamó a **MAPIInitIdle**.</span><span class="sxs-lookup"><span data-stu-id="d1b75-135">All idle tasks run on the thread that called **MAPIInitIdle**.</span></span> <span data-ttu-id="d1b75-136">MAPI tiene un subproceso independiente para la programación, pero cuando se convierte en una tarea inactiva elegible, envía un mensaje vuelta al subproceso de inicialización y la tarea inactivo se ejecuta no existe.</span><span class="sxs-lookup"><span data-stu-id="d1b75-136">MAPI has a separate thread for scheduling, but when an idle task becomes eligible, it posts a message back over to the initialization thread and the idle task is executed there.</span></span> <span data-ttu-id="d1b75-137">Las implicaciones de distintos tipos de clientes son los siguientes.</span><span class="sxs-lookup"><span data-stu-id="d1b75-137">The implications for different types of clients are as follows.</span></span>
  
|<span data-ttu-id="d1b75-138">**Modelo de subprocesos**</span><span class="sxs-lookup"><span data-stu-id="d1b75-138">**Threading model**</span></span>|<span data-ttu-id="d1b75-139">**Implicación**</span><span class="sxs-lookup"><span data-stu-id="d1b75-139">**Implication**</span></span>|
|:-----|:-----|
|<span data-ttu-id="d1b75-140">Un único subproceso</span><span class="sxs-lookup"><span data-stu-id="d1b75-140">Single-threaded</span></span>  <br/> |<span data-ttu-id="d1b75-141">No hay problema.</span><span class="sxs-lookup"><span data-stu-id="d1b75-141">No problem.</span></span> <span data-ttu-id="d1b75-142">Funciones de inactividad de ejecución en el subproceso principal de su cliente y se puede serializar a través del bucle de mensaje.</span><span class="sxs-lookup"><span data-stu-id="d1b75-142">Idle functions execute on your client's main thread and are serialized through the message loop.</span></span>  <br/> |
|<span data-ttu-id="d1b75-143">Subprocesamiento libre</span><span class="sxs-lookup"><span data-stu-id="d1b75-143">Free-threaded</span></span>  <br/> |<span data-ttu-id="d1b75-144">Funciones de inactividad deben ser seguros para subprocesos, pero el cliente ya tiene la infraestructura necesaria.</span><span class="sxs-lookup"><span data-stu-id="d1b75-144">Idle functions must be thread-safe, but your client already has the necessary infrastructure.</span></span> <span data-ttu-id="d1b75-145">El cliente no es posible que necesita el motor de inactividad de MAPI en absoluto.</span><span class="sxs-lookup"><span data-stu-id="d1b75-145">Your client might not need the MAPI idle engine at all.</span></span>  <br/> |
|<span data-ttu-id="d1b75-146">Subprocesamiento controlado</span><span class="sxs-lookup"><span data-stu-id="d1b75-146">Apartment-threaded</span></span>  <br/> |<span data-ttu-id="d1b75-147">Función inactivo tiene que ejecutarse en el mismo subproceso que lo registró si desea utilizar MAPI, OLE o cualquier otros interfaces COM.</span><span class="sxs-lookup"><span data-stu-id="d1b75-147">Idle function has to execute on the same thread that registered it if it wants to use MAPI, OLE, or any other COM interfaces.</span></span> <span data-ttu-id="d1b75-148">Es la manera más sencilla registrar una función de inactividad con MAPI que se envía un mensaje al subproceso de la derecha y la función "real" inactividad directamente desde el bucle de mensajes del subproceso que de distribución.</span><span class="sxs-lookup"><span data-stu-id="d1b75-148">The most straightforward way is to register an idle function with MAPI that posts a message to the right thread and dispatch the "real" idle function directly from that thread's message loop.</span></span>  <br/> |
   

