---
title: Implementación de objetos seguros para subProcesos
manager: soliver
ms.date: 11/16/2014
ms.audience: Developer
localization_priority: Normal
api_type:
- COM
ms.assetid: 3c911694-b953-4d35-9a3a-22c17cfd79bc
description: 'Última modificación: 23 de julio de 2011'
ms.openlocfilehash: 9160136542c7960bad0be2423872171b17d99fe3
ms.sourcegitcommit: 8fe462c32b91c87911942c188f3445e85a54137c
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 04/23/2019
ms.locfileid: "32310041"
---
# <a name="implementing-thread-safe-objects"></a><span data-ttu-id="d7209-103">Implementación de objetos seguros para subProcesos</span><span class="sxs-lookup"><span data-stu-id="d7209-103">Implementing Thread-Safe Objects</span></span>

  
  
<span data-ttu-id="d7209-104">**Se aplica a**: Outlook 2013 | Outlook 2016</span><span class="sxs-lookup"><span data-stu-id="d7209-104">**Applies to**: Outlook 2013 | Outlook 2016</span></span> 
  
<span data-ttu-id="d7209-105">Con los objetos que se devuelven directamente desde las llamadas a métodos de interfaz, es responsabilidad del proveedor garantizar la seguridad de los subprocesos.</span><span class="sxs-lookup"><span data-stu-id="d7209-105">With objects that are returned from interface method calls directly, it is the provider's responsibility to ensure thread-safety.</span></span> <span data-ttu-id="d7209-106">Con los objetos de devolución de llamada, es responsabilidad de la aplicación cliente.</span><span class="sxs-lookup"><span data-stu-id="d7209-106">With callback objects, it is the client application's responsibility.</span></span>
  
<span data-ttu-id="d7209-107">Un cliente puede implementar una devolución de llamada de notificación segura para subprocesos llamando a la utilidad [HrThisThreadAdviseSink](hrthisthreadadvisesink.md)de MAPI.</span><span class="sxs-lookup"><span data-stu-id="d7209-107">A client can implement a thread-safe notification callback by calling the MAPI utility [HrThisThreadAdviseSink](hrthisthreadadvisesink.md).</span></span> <span data-ttu-id="d7209-108">**HrThisThreadAdviseSink** transforma un receptor no seguro para subprocesos en uno seguro para subprocesos.</span><span class="sxs-lookup"><span data-stu-id="d7209-108">**HrThisThreadAdviseSink** transforms a non-thread-safe advise sink into a thread-safe one.</span></span> <span data-ttu-id="d7209-109">Para las devoluciones de llamada de progreso, no existe dicha utilidad.</span><span class="sxs-lookup"><span data-stu-id="d7209-109">For progress callbacks, there is no such utility.</span></span> <span data-ttu-id="d7209-110">Un cliente puede elegir usar el objeto de progreso seguro para subprocesos MAPI o crear uno manualmente.</span><span class="sxs-lookup"><span data-stu-id="d7209-110">A client can choose to use the MAPI thread-safe progress object or create one manually.</span></span> 
  
<span data-ttu-id="d7209-111">Un objeto seguro para subprocesos también puede o no ser compatible con subprocesos.</span><span class="sxs-lookup"><span data-stu-id="d7209-111">A thread-safe object might or might not also be thread-aware.</span></span> <span data-ttu-id="d7209-112">Un objeto de reconocimiento de subproceso mantiene un contexto independiente para cada subproceso que lo está usando.</span><span class="sxs-lookup"><span data-stu-id="d7209-112">A thread-aware object maintains a separate context for every thread that is using it.</span></span> <span data-ttu-id="d7209-113">No es necesario que los proveedores de servicios admitan el reconocimiento de subprocesos en sus objetos seguros para subprocesos, aunque es posible que resulte útil admitir el reconocimiento de subprocesos en algunas situaciones.</span><span class="sxs-lookup"><span data-stu-id="d7209-113">Service providers are not required to support thread-awareness in their thread-safe objects, although supporting thread-awareness can be useful in some situations.</span></span> <span data-ttu-id="d7209-114">Dos tablas MAPI siempre proporcionan su propio contexto por definición.</span><span class="sxs-lookup"><span data-stu-id="d7209-114">Two MAPI tables always provide their own context by definition.</span></span> <span data-ttu-id="d7209-115">Una tabla usada en subprocesos distintos no y no debe proporcionar un contexto único.</span><span class="sxs-lookup"><span data-stu-id="d7209-115">One table used on different threads does not and should not provide unique context.</span></span>
  
<span data-ttu-id="d7209-116">Un cliente puede elegir entre recibir notificaciones en el mismo subproceso que se usó para la llamada **MAPIInitialize** , en el mismo subproceso que se usó para la llamada a Advise, o en un subproceso independiente propiedad de MAPI. \*\*\*\*</span><span class="sxs-lookup"><span data-stu-id="d7209-116">A client can choose between receiving notifications on the same thread that was used for the **MAPIInitialize** call, on the same thread that was used for the **Advise** call, or on a separate thread owned by MAPI.</span></span> <span data-ttu-id="d7209-117">Para asegurarse de que las notificaciones llegan al mismo subproceso que se usó para llamar a **MAPIInitialize**, un cliente llama a [MAPIInitialize](mapiinitialize.md) y pasa cero en el miembro **ulFlags** de la estructura [MAPIINIT_0](mapiinit_0.md) .</span><span class="sxs-lookup"><span data-stu-id="d7209-117">To ensure that notifications arrive on the same thread that was used to call **MAPIInitialize**, a client calls [MAPIInitialize](mapiinitialize.md) and passes zero in the **ulFlags** member of the [MAPIINIT_0](mapiinit_0.md) structure.</span></span> <span data-ttu-id="d7209-118">A continuación, las notificaciones se entregan durante el bucle de mensajes principal.</span><span class="sxs-lookup"><span data-stu-id="d7209-118">Notifications are then delivered during the main message loop.</span></span> 
  
<span data-ttu-id="d7209-119">Para recibir notificaciones en el subproceso de propiedad de MAPI, un cliente llama a **MAPIInitialize** con el miembro **ulFlags** de la estructura **MAPIINIT_0** establecida en MAPI_MULTITHREAD_NOTIFICATIONS.</span><span class="sxs-lookup"><span data-stu-id="d7209-119">To receive notifications on the MAPI-owned thread, a client calls **MAPIInitialize** with the **ulFlags** member of the **MAPIINIT_0** structure set to MAPI_MULTITHREAD_NOTIFICATIONS.</span></span> <span data-ttu-id="d7209-120">La \*\*\*\* llamada a Advise se realiza con el objeto de notificaciones de aviso del cliente en lugar de una versión ajustada.</span><span class="sxs-lookup"><span data-stu-id="d7209-120">The **Advise** call is made with the client's advise sink object rather than a wrapped version.</span></span> 
  
<span data-ttu-id="d7209-121">Para asegurarse de que las notificaciones llegan en el mismo subproceso que se \*\*\*\* usó para llamar a Advise, un cliente llama a [HrThisThreadAdviseSink](hrthisthreadadvisesink.md) y pasa el receptor encapsulado recién creado a Advise en lugar del receptor de notificaciones original. \*\*\*\*</span><span class="sxs-lookup"><span data-stu-id="d7209-121">To ensure that notifications arrive on the same thread that was used to call **Advise**, a client calls [HrThisThreadAdviseSink](hrthisthreadadvisesink.md) and passes the newly created wrapped advise sink to **Advise** rather than the original advise sink.</span></span> <span data-ttu-id="d7209-122">Se puede llamar a **MAPIInitialize** con cualquier valor de marca.</span><span class="sxs-lookup"><span data-stu-id="d7209-122">**MAPIInitialize** can be called with either flag value.</span></span> 
  

