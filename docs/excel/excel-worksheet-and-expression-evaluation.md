---
title: Hojas de c�lculo y evaluaci�n de expresiones de Excel
manager: soliver
ms.date: 03/09/2015
ms.audience: Developer
ms.topic: overview
keywords:
- expression evaluation [excel 2007],errors in worksheets [Excel 2007],long Unicode strings [Excel 2007],evaluating expressions [Excel 2007],evaluating worksheets [Excel 2007],worksheet evaluation [Excel 2007],worksheet errors [Excel 2007]
localization_priority: Normal
ms.assetid: 47b46a7d-6cfb-4f5b-946d-e0164d18512a
description: 'Hace referencia a: Excel 2013 | Office 2013 | Visual Studio'
ms.openlocfilehash: cf1e0539136435f7d7df6ef348fc92ec4380e132
ms.sourcegitcommit: 8fe462c32b91c87911942c188f3445e85a54137c
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 04/23/2019
ms.locfileid: "32310987"
---
# <a name="excel-worksheet-and-expression-evaluation"></a><span data-ttu-id="59c4b-104">Hojas de cálculo y evaluación de expresiones de Excel</span><span class="sxs-lookup"><span data-stu-id="59c4b-104">Excel Worksheet and Expression Evaluation</span></span>

 <span data-ttu-id="59c4b-105">**Hace referencia a**: Excel 2013 | Office 2013 | Visual Studio</span><span class="sxs-lookup"><span data-stu-id="59c4b-105">**Applies to**: Excel 2013 | Office 2013 | Visual Studio</span></span> 
  
<span data-ttu-id="59c4b-106">El contenido de las celdas de la hoja de cálculo de Microsoft Excel se evalúa en uno de los cuatro tipos de datos básicos:</span><span class="sxs-lookup"><span data-stu-id="59c4b-106">Microsoft Excel worksheet cell contents are evaluated into one of four basic data types:</span></span>
  
- <span data-ttu-id="59c4b-107">**Numbers**</span><span class="sxs-lookup"><span data-stu-id="59c4b-107">**Numbers**</span></span>
    
- <span data-ttu-id="59c4b-108">**Boolean TRUE** o **FALSE**</span><span class="sxs-lookup"><span data-stu-id="59c4b-108">**Boolean TRUE** or **FALSE**</span></span>
    
- <span data-ttu-id="59c4b-109">**Strings**</span><span class="sxs-lookup"><span data-stu-id="59c4b-109">**Strings**</span></span>
    
- <span data-ttu-id="59c4b-110">**Errors**</span><span class="sxs-lookup"><span data-stu-id="59c4b-110">**Errors**</span></span>
    
<span data-ttu-id="59c4b-111">Las matrices de tipos mixtos de estos tipos también se pueden introducir en fórmulas como argumentos para funciones o como valores que expanden más de una celda de una fórmula de matriz.</span><span class="sxs-lookup"><span data-stu-id="59c4b-111">Mixed-type arrays of these types can also be entered into formulas as arguments to functions or as values spanning more than one cell in an array formula.</span></span>
  
<span data-ttu-id="59c4b-p101">Cuando un usuario (o una macro de comandos) escribe algo en una celda, Excel intenta interpretar la entrada y muestra un mensaje de error si no puede. Si la entrada se empieza por un prefijo de cadena (una comilla simple), Excel coloca todos los caracteres de entrada en la celda tal como los proporciona, sin modificar. (El prefijo de cadena no se muestra). Si la entrada empieza por **=**, **+** o **-**, Excel intenta interpretar la entrada como una fórmula. Si la sintaxis es incorrecta o se detiene la evaluación, se muestra un error y la celda se pone en modo de edición. De lo contrario, Excel intenta identificar, convertir y evaluar los operadores y los nombres de la función, y sus argumentos.</span><span class="sxs-lookup"><span data-stu-id="59c4b-p101">When a user (or a command macro) enters something into a cell, Excel tries to interpret the input and displays an error message if it cannot. If the input starts with a string prefix (a single quotation mark) Excel places all the input characters in the cell as provided, with no modification. (The string prefix is not displayed.) If the input begins with **=**, **+**, or **-**, Excel tries to interpret the input as a formula. If the syntax is incorrect or evaluation is stopped, an error is displayed, and the cell is put in edit mode. Otherwise, Excel tries to identify, convert, and evaluate operators and function names and their arguments.</span></span> 
  
<span data-ttu-id="59c4b-p102">Antes de aplicar el operador, los operandos se evalúan de izquierda a derecha. Las funciones se evalúan a partir de los operadores de mayor prioridad y más internos (más anidados). Si los argumentos de función o los operandos no se pueden convertir a los tipos esperados, la evaluación produce un error y da como resultado un error **#VALUE!**. Cuando no se reconoce un token (que no es un valor literal) como una función, o un nombre o una etiqueta definida, la evaluación produce un error y da como resultado un error **#NAME?**.</span><span class="sxs-lookup"><span data-stu-id="59c4b-p102">Operands are evaluated from left to right before the operator is applied. Functions are evaluated starting with the highest-precedence operators and innermost (most nested). If function arguments or operands cannot be converted to the types expected, evaluation fails and results in a **#VALUE!** error. When a token (that is not a literal value) is not recognized as a function or defined name or label, evaluation fails and results in a **#NAME?** error.</span></span> 
  
<span data-ttu-id="59c4b-p103">Si la entrada no empieza por cualquiera de estos, Excel comprueba los patrones conocidos de entrada, como fechas, horas, cantidades de moneda, porcentajes o números, y los interpreta según corresponda. Esto se hace de forma específica de la configuración regional. Si ninguna de estas interpretaciones tiene sentido, Excel vuelve a considerar la entrada como una cadena y la coloca en la celda sin cambiar.</span><span class="sxs-lookup"><span data-stu-id="59c4b-p103">If the input does not start with any of these things, Excel checks against known patterns of input such as dates, times, currency amounts, percentages, or numbers, and interprets accordingly. This is done in a locale-specific way. If none of these interpretations makes sense, Excel reverts to considering the input as a string and places it in the cell unchanged.</span></span>
  
<span data-ttu-id="59c4b-p104">Excel admite otros tipos de datos, el más visible de ellos es una referencia de rango. Excel convierte las referencias a los valores de las celdas a las que hace referencia al evaluar los argumentos para los operadores y las funciones que no toman argumentos de referencia, o cuando la expresión de una fórmula de celda se reduce a una referencia.</span><span class="sxs-lookup"><span data-stu-id="59c4b-p104">Excel supports other data types, the most visible of which is a range reference. Excel converts references to the values of the referred-to cells when evaluating arguments for operators and functions that do not take reference arguments, or when the expression in a cell formula reduces to a reference.</span></span>
  
<span data-ttu-id="59c4b-p105">Excel expone la capacidad de reducir cualquier cadena de caracteres válidos a uno de los cuatro tipos de datos de hoja de cálculo básicos con **EVALUATE** de la función XLM y su equivalente de la API de C **xlfEvaluate**. Entre otras cosas, esta función proporciona una manera sencilla de evaluar los rangos con nombre en código de la DLL. Esta función difiere del comportamiento descrito anteriormente solo en que en lugar de mostrar mensajes de error o habilitar la edición de la celda, devuelve un error **#VALUE!** si se produce un error en la evaluación de la expresión.</span><span class="sxs-lookup"><span data-stu-id="59c4b-p105">Excel exposes the ability to reduce any valid character string to one of the basic four worksheet data types with the XLM function **EVALUATE** and its C API equivalent **xlfEvaluate**. This function provides, among other things, a simple way to evaluate named ranges in DLL code. This function differs from the behavior described earlier only in that instead of displaying error messages or enabling cell editing, it returns a **#VALUE!** error if the expression evaluation fails.</span></span> 
  
## <a name="numbers"></a><span data-ttu-id="59c4b-131">Números</span><span class="sxs-lookup"><span data-stu-id="59c4b-131">Numbers</span></span>

<span data-ttu-id="59c4b-p106">Todos los números de hoja de cálculo de Excel se representan internamente como un número de punto flotante de precisión doble de 8 bytes, incluidos todos los enteros. Sin embargo, la implementación de estos números en Excel no es totalmente compatible con IEEE, como se muestra en la siguiente tabla.</span><span class="sxs-lookup"><span data-stu-id="59c4b-p106">All worksheet numbers in Excel are represented internally as 8-byte double-precision floating point, including all integers. However, the implementation of these numbers in Excel is not fully IEEE compliant, as shown in the following table.</span></span>
  
|<span data-ttu-id="59c4b-134">**Tipo**</span><span class="sxs-lookup"><span data-stu-id="59c4b-134">**Type**</span></span>|<span data-ttu-id="59c4b-135">**Máximo**</span><span class="sxs-lookup"><span data-stu-id="59c4b-135">**Maximum**</span></span>|<span data-ttu-id="59c4b-136">**Mínimo**</span><span class="sxs-lookup"><span data-stu-id="59c4b-136">**Minimum**</span></span>|
|:-----|:-----|:-----|
|<span data-ttu-id="59c4b-137">Doble de 8 bytes IEEE</span><span class="sxs-lookup"><span data-stu-id="59c4b-137">IEEE 8-byte double</span></span>  <br/> |<span data-ttu-id="59c4b-138">1.7976931348623157E+308</span><span class="sxs-lookup"><span data-stu-id="59c4b-138">1.7976931348623157E+308</span></span>  <br/> |<span data-ttu-id="59c4b-139">2.2250738585072014E-308</span><span class="sxs-lookup"><span data-stu-id="59c4b-139">2.2250738585072014E-308</span></span>  <br/> |
|<span data-ttu-id="59c4b-140">Hoja de cálculo (devuelto por la función o el valor de pegado)</span><span class="sxs-lookup"><span data-stu-id="59c4b-140">Worksheet (returned by function or paste value)</span></span>  <br/> |<span data-ttu-id="59c4b-141">1.7976931348623157E+308</span><span class="sxs-lookup"><span data-stu-id="59c4b-141">1.7976931348623157E+308</span></span>  <br/> |<span data-ttu-id="59c4b-142">2.22507385850721E-308</span><span class="sxs-lookup"><span data-stu-id="59c4b-142">2.22507385850721E-308</span></span>  <br/> |
|<span data-ttu-id="59c4b-143">Hoja de cálculo (entrada manual)</span><span class="sxs-lookup"><span data-stu-id="59c4b-143">Worksheet (manual input)</span></span>  <br/> |<span data-ttu-id="59c4b-144">9.99999999999999E+307</span><span class="sxs-lookup"><span data-stu-id="59c4b-144">9.99999999999999E+307</span></span>  <br/> |<span data-ttu-id="59c4b-145">2.22507385850721E-308</span><span class="sxs-lookup"><span data-stu-id="59c4b-145">2.22507385850721E-308</span></span>  <br/> |
   
<span data-ttu-id="59c4b-146">Los números de IEEE por debajo de lo normal (es decir, los números del rango 2,2250738585072009E \endash 308 4,9406564584124654E \endash 324) no se admiten en las hojas de cálculo de Excel, pero se admiten en los dobles de VBA.</span><span class="sxs-lookup"><span data-stu-id="59c4b-146">IEEE subnormal numbers (that is, numbers in the range 2.2250738585072009E-308 to 4.9406564584124654E-324) are not supported in Excel worksheets but are supported by VBA Doubles.</span></span>
  
<span data-ttu-id="59c4b-p107">Si una función DLL devuelve IEEE +/- infinity o un doble no válido, Excel lo convierte en **#NUM!**. Todos los números por debajo de lo normal y los números menores que el normal positivo mínimo de Excel se convierten en cero positivo. Se admite el cero negativo de IEEE, es decir, una función DLL lo puede devolver y se muestra como **-0**. (El operador **\<** no busca el cero negativo y, por lo tanto **=A1\<0** se evalúa como **TRUE** si A1 contiene un cero negativo).</span><span class="sxs-lookup"><span data-stu-id="59c4b-p107">If a DLL function returns IEEE +/- infinity or an invalid double, Excel converts it to **#NUM!**. All subnormal numbers and numbers smaller than the minimum positive normal in Excel are converted to positive zero. IEEE negative zero is supported, that is, it can be returned by a DLL function and is displayed as **-0**. (The **\<** operator does not check for negative zero, and so **=A1\<0** evaluates to **TRUE** if A1 contains negative zero).</span></span> 
  
<span data-ttu-id="59c4b-p108">Tenga en cuenta que algunos formatos de número tienen límites más estrechos, por ejemplo, fechas y horas. La división de enteros es, de hecho, una división de número de punto flotante y puede, en casos extremos, dar un resultado no entero cuando el resultado preciso debería ser un entero.</span><span class="sxs-lookup"><span data-stu-id="59c4b-p108">Note that certain number formats have narrower limits than these, for example, dates and times. Integer division is, in fact, floating point division and might, in extreme cases, yield a non-integer result where the precise result should be an integer.</span></span>
  
## <a name="long-unicode-strings"></a><span data-ttu-id="59c4b-153">Cadenas Unicode largas</span><span class="sxs-lookup"><span data-stu-id="59c4b-153">Long Unicode Strings</span></span>

<span data-ttu-id="59c4b-p109">Todas las cadenas que el usuario ve en Excel, desde hace muchas versiones, se almacenan internamente como cadenas Unicode. Las cadenas de la hoja de cálculo de Unicode pueden ser de hasta 32.767 (2<sup>15</sup>- 1) caracteres de longitud y pueden contener cualquier carácter Unicode válido.</span><span class="sxs-lookup"><span data-stu-id="59c4b-p109">All strings the user sees in Excel have for many versions now been stored internally as Unicode strings. Unicode worksheet strings can be up to 32,767 (2<sup>15</sup> - 1) characters in length and can contain any valid Unicode character.</span></span> 
  
<span data-ttu-id="59c4b-p110">Al introducir la API de C, las cadenas de hoja de cálculo eran cadenas de bytes limitadas a una longitud de 255 caracteres, y la API de C reflejaba estos límites. Con Excel 2007, la API de C se actualiza para controlar cadenas Unicode largas de Excel. Esto significa que funciones DLL registradas correctamente pueden aceptar argumentos Unicode y devolver las cadenas Unicode.</span><span class="sxs-lookup"><span data-stu-id="59c4b-p110">When the C API was first introduced, worksheet strings were byte strings limited in length to 255 characters, and the C API reflected these limitations. With Excel 2007, the C API is updated to handle Excel long Unicode strings. This means that DLL functions registered in the right way can accept Unicode arguments and return Unicode strings.</span></span>
  
> [!NOTE]
> <span data-ttu-id="59c4b-159">Las cadenas de bytes todavía se admiten totalmente en la API de C para la compatibilidad con versiones anteriores. Sin embargo, siguen teniendo el mismo límite de 255 caracteres.</span><span class="sxs-lookup"><span data-stu-id="59c4b-159">Byte strings are still fully supported in the C API for backward compatibility; however they still have the same 255-character limit.</span></span> 
  
## <a name="returning-errors"></a><span data-ttu-id="59c4b-160">Devolver errores</span><span class="sxs-lookup"><span data-stu-id="59c4b-160">Returning Errors</span></span>

<span data-ttu-id="59c4b-p111">Excel evalúa las celdas para buscar errores cuando no puede convertir los argumentos de función o de operador al tipo correcto, o si no reconoce una función o un nombre definido. Estos dos escenarios se describen anteriormente. Cuando los operadores y las funciones de hoja de cálculo integradas fallan, producen errores que informan al usuario del tipo de error. Debe hacer que las funciones de complemento devuelvan errores coherentes con el comportamiento en Excel.</span><span class="sxs-lookup"><span data-stu-id="59c4b-p111">Excel evaluates cells to errors where it cannot convert function or operator arguments to the correct type, or if it does not recognize a function or defined name. Both of these scenarios were described earlier. When the built-in worksheet functions and operators fail, they also result in errors that inform the user of the type of failure. You should have your own add-in functions return errors that are consistent with the behavior in Excel.</span></span>
  
### <a name="null"></a><span data-ttu-id="59c4b-165">#NULL!</span><span class="sxs-lookup"><span data-stu-id="59c4b-165">#NULL!</span></span>

<span data-ttu-id="59c4b-p112">Algunas funciones de información XML devuelven el error **#NULL!**. Por ejemplo, al llamar a **GET.DOCUMENT(78)** o a la función de la API de C equivalente **xlfGetDocument** con el argumento 78, cuando no hay resultados de impresoras instalados en este error que se devuelve. Algunas funciones también pueden devolverlos cuando, por ejemplo, evalúan una cadena vacía.</span><span class="sxs-lookup"><span data-stu-id="59c4b-p112">The **#NULL!** error is returned by some XLM information functions. For example, calling **GET.DOCUMENT(78)**, or the equivalent C API function **xlfGetDocument** with argument 78, when there are no printers installed results in this error being returned. It can also be returned by some functions when, for example, they evaluate an empty string.</span></span> 
  
<span data-ttu-id="59c4b-170">Es posible que quiera devolver este error de la función de complemento cuando ninguno de los otros errores sea adecuado.</span><span class="sxs-lookup"><span data-stu-id="59c4b-170">You might want to return this error from your add-in function when none of the other errors seems appropriate.</span></span>
  
### <a name="div0"></a><span data-ttu-id="59c4b-171">#DIV/0!</span><span class="sxs-lookup"><span data-stu-id="59c4b-171">#DIV/0!</span></span>

<span data-ttu-id="59c4b-p113">El operador de división de Excel devuelve el error **#DIV/0!** cuando el denominador se evalúa en cero o un número es demasiado pequeño para ser representado como distinto de cero por Excel. Algunas funciones que, por definición, implican una división, también pueden devolver este error. Por ejemplo, **AVERAGE** devuelve este error si ninguna de las entradas se puede convertir a números.</span><span class="sxs-lookup"><span data-stu-id="59c4b-p113">The Excel division operator returns the **#DIV/0!** error when the denominator evaluates to zero or a number is too small to be represented as non-zero by Excel. Some functions that by definition involve a division can also return this error. For example, **AVERAGE** returns this error if none of the inputs can be converted to numbers.</span></span> 
  
<span data-ttu-id="59c4b-176">Solo debe considerar devolver este error desde la función de complemento para indicar que se detectó una división entre cero.</span><span class="sxs-lookup"><span data-stu-id="59c4b-176">You should only consider returning this error from your add-in function to indicate that a division by zero was detected.</span></span>
  
### <a name="value"></a><span data-ttu-id="59c4b-177">#VALUE!</span><span class="sxs-lookup"><span data-stu-id="59c4b-177">#VALUE!</span></span>

<span data-ttu-id="59c4b-p114">Excel devuelve el error **#VALUE!** si una función o un argumento de operador no se puede convertir al tipo necesario. En el caso de los argumentos de función que no se pueden convertir, por ejemplo  `=LN("X")`, Excel no llama al código de función. Este es un punto que se debe recordar al escribir y depurar las funciones de complemento.</span><span class="sxs-lookup"><span data-stu-id="59c4b-p114">Excel returns the **#VALUE!** error if a function or operator argument cannot be converted to the required type. In the case of function arguments that cannot be converted, for example  `=LN("X")`, Excel does not call the function code. This is an important point to remember when writing and debugging your own add-in functions.</span></span> 
  
<span data-ttu-id="59c4b-p115">Algunas funciones devuelven este error si no se puede convertir un argumento dentro del código de función. Por ejemplo,  `DATEVALUE("30-Feb-2007")` se produce este error a pesar de que el argumento es del tipo correcto. En este caso, es la función la que devuelve el error desde dentro de su código. Algunas funciones devuelven este error aunque se permitan los tipos de valor y los intervalos, por ejemplo  `FIND("a","xyz")` devuelve este error.</span><span class="sxs-lookup"><span data-stu-id="59c4b-p115">Some functions return this error if an argument cannot be converted within the function code. For example,  `DATEVALUE("30-Feb-2007")` fails with this error despite the argument being of the right type. In this case, it is the function that is returning the error from within its code. Some functions return this error even though the value types and ranges are allowable, for example  `FIND("a","xyz")` returns this error.</span></span> 
  
<span data-ttu-id="59c4b-p116">Debe considerar devolver este error desde la función de complemento para indicar que los argumentos son del tipo incorrecto, no se pueden convertir al tipo correcto o están fuera del rango, aunque debe devolver **#NUM!** para los argumentos numéricos fuera del rango. También debe considerar devolver este error cuando los argumentos de rango o de matriz tienen el tamaño o la forma incorrectos.</span><span class="sxs-lookup"><span data-stu-id="59c4b-p116">You should consider returning this error from your add-in function to indicate that the arguments are of the wrong type, could not be converted to the right type, or are out of range, although you should consider returning **#NUM!** for numerical arguments out of range. You should also consider returning this error when range or array arguments are the wrong shape or size.</span></span> 
  
### <a name="ref"></a><span data-ttu-id="59c4b-189">#REF!</span><span class="sxs-lookup"><span data-stu-id="59c4b-189">#REF!</span></span>

<span data-ttu-id="59c4b-p117">Excel genera el error **#REF!** dentro de una expresión cuando se copia en una ubicación donde la referencia relativa resultante queda fuera de los límites. Por ejemplo, si la celda B2 contiene la fórmula  `=A1`, copiarlo en la celda B1 da como resultado una fórmula **=#REF!**. Este error también se genera en las fórmulas que contienen una referencia que se sobrescribe en una operación de cortar y pegar, o se elimina de una fila, columna o eliminación de hoja de cálculo. Algunas funciones que pueden devolver referencias, pueden devolver este error, por ejemplo,  `OFFSET(A1,-1,-1)`. Los nombres de hoja de cálculo cuyas definiciones contienen referencias que dejan de ser válidas se evalúan para este error.</span><span class="sxs-lookup"><span data-stu-id="59c4b-p117">Excel generates the **#REF!** error within an expression when it is copied to a location where the resulting relative reference goes out of bounds. For example, if the cell B2 contains the formula  `=A1`, copying this to cell B1 results in a formula **=#REF!**. This error is also generated in formulas that contain a reference that is overwritten in a cut-and-paste operation or is deleted in a row, column, or worksheet deletion. Some functions that can return references can return this error, for example,  `OFFSET(A1,-1,-1)`. Worksheet names whose definitions contain references that become invalid are evaluated to this error.</span></span>
  
<span data-ttu-id="59c4b-p118">Si la función de complemento toma argumentos de referencia, considere devolver este error si las referencias no son válidas, o si pasa un error de referencia. La sección sobre XLOPER o XLOPER12 de [administración de memoria en Excel](memory-management-in-excel.md) describe cómo crear funciones que pueden aceptar y devolver argumentos de referencia.</span><span class="sxs-lookup"><span data-stu-id="59c4b-p118">If your add-in function takes reference arguments, you should consider returning this error if the references are invalid, or if you are passed a reference error. The section on XLOPER/XLOPER12s in [Memory Management in Excel](memory-management-in-excel.md) describes how to create functions that can accept and return reference arguments.</span></span> 
  
### <a name="name"></a><span data-ttu-id="59c4b-198">#NAME?</span><span class="sxs-lookup"><span data-stu-id="59c4b-198">#NAME?</span></span>

<span data-ttu-id="59c4b-p119">Excel genera el error **#NAME?** cuando una expresión contiene un token no reconocido como una función o un nombre definido. Si la función de complemento acceder a un nombre definido y no está definido, considere devolver este error.</span><span class="sxs-lookup"><span data-stu-id="59c4b-p119">Excel generates the **#NAME?** error when an expression contains a token that is not recognized as a function or defined name. If your add-in function tries to access a defined name and it is not defined, you should consider returning this error.</span></span> 
  
### <a name="num"></a><span data-ttu-id="59c4b-201">#NUM!</span><span class="sxs-lookup"><span data-stu-id="59c4b-201">#NUM!</span></span>

<span data-ttu-id="59c4b-p120">Muchas de las funciones matemáticas y numéricas integradas de Excel devuelven el error **#NUM!** cuando una entrada numérica está fuera del rango permitido, por ejemplo,  `LN(0)`. Considere devolver este error desde la función de complemento para indicar que una entrada numérica no era válida o estaba fuera del rango.</span><span class="sxs-lookup"><span data-stu-id="59c4b-p120">Many of the built-in numerical and mathematical functions in Excel return the **#NUM!** error when a numerical input is out of the permitted range, for example,  `LN(0)`. You should consider returning this error from your add-in function to indicate that a numerical input was invalid or out of range.</span></span>
  
### <a name="na"></a><span data-ttu-id="59c4b-205">#N/A</span><span class="sxs-lookup"><span data-stu-id="59c4b-205">#N/A</span></span>

<span data-ttu-id="59c4b-p121">A menudo se devuelve el error **#N/A** para indicar que un resultado correcto o significativo no está disponible. Por ejemplo, MATCH con el tercer cero de argumento devuelve este error si no se encuentra una coincidencia exacta. Este error también se puede generar con la función **NA** y se puede detectar específicamente con la función **ISNA**. Por lo tanto, es un error frecuente en hojas de cálculo para indicar un rango de condiciones específicas de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="59c4b-p121">The **#N/A** error is often returned to signify a successful or meaningful result is not available. For example, MATCH with the third argument zero returns this error if an exact match cannot be found. This error can also be generated using the function **NA** and specifically detected with the function **ISNA**. It is therefore a commonly used error in worksheets to indicate a range of application-specific conditions.</span></span>
  
## <a name="see-also"></a><span data-ttu-id="59c4b-210">Vea también</span><span class="sxs-lookup"><span data-stu-id="59c4b-210">See also</span></span>



[<span data-ttu-id="59c4b-211">Conceptos de programación de Excel</span><span class="sxs-lookup"><span data-stu-id="59c4b-211">Excel Programming Concepts</span></span>](excel-programming-concepts.md)
  
[<span data-ttu-id="59c4b-212">Programar con la API de C en Excel</span><span class="sxs-lookup"><span data-stu-id="59c4b-212">Programming with the C API in Excel</span></span>](programming-with-the-c-api-in-excel.md)
  
[<span data-ttu-id="59c4b-213">Evaluar los nombres y otras expresiones de fórmulas de la hoja de cálculo</span><span class="sxs-lookup"><span data-stu-id="59c4b-213">Evaluating Names and Other Worksheet Formula Expressions</span></span>](evaluating-names-and-other-worksheet-formula-expressions.md)
  
[<span data-ttu-id="59c4b-214">Referencia de funciones de API de SDK de XLL de Excel 2013</span><span class="sxs-lookup"><span data-stu-id="59c4b-214">Excel XLL SDK API Function Reference</span></span>](excel-xll-sdk-api-function-reference.md)

